webpackJsonp([31],{51:function(s,a,n){var l,i;__vdoc_config_=n(77),i=n(123),s.exports=l||{},s.exports.__esModule&&(s.exports=s.exports["default"]),i&&(("function"==typeof s.exports?s.exports.options:s.exports).html=i)},77:function(s,a){},123:function(s,a){s.exports="<p>在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用<strong>计算属性</strong>。</p> <h3 id=->基础例子</h3> <figure class=\"highlight html\"><table><tr><td class=code><pre><div class=line><span class=tag>&lt;<span class=name>div</span> <span class=attr>id</span>=<span class=string>\"example\"</span>&gt;</span></div><div class=line>  a={{ a }}, b={{ b }}</div><div class=line><span class=tag>&lt;/<span class=name>div</span>&gt;</span></div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=code><pre><div class=line><span class=keyword>var</span> vm = <span class=keyword>new</span> Vue({</div><div class=line>  el: <span class=string>'#example'</span>,</div><div class=line>  data: {</div><div class=line>    a: <span class=number>1</span></div><div class=line>  },</div><div class=line>  computed: {</div><div class=line>    <span class=comment>// 一个计算属性的 getter</span></div><div class=line>    b: <span class=function><span class=keyword>function</span> (<span class=params></span>) </span>{</div><div class=line>      <span class=comment>// `this` 指向 vm 实例</span></div><div class=line>      <span class=keyword>return</span> <span class=keyword>this</span>.a + <span class=number>1</span></div><div class=line>    }</div><div class=line>  }</div><div class=line>})</div></pre></td></tr></table></figure><p>结果：</p> <p></p><div id=example class=demo> a={{ a }}, b={{ b }} </div><p></p> <script>var vm=new Vue({el:\"#example\",data:{a:1},computed:{b:function(){return this.a+1}}})</script> <p>这里我们声明了一个计算属性 <code>b</code>。我们提供的函数将用作属性 <code>vm.b</code>的 getter。</p> <figure class=\"highlight js\"><table><tr><td class=code><pre><div class=line><span class=built_in>console</span>.log(vm.b) <span class=comment>// -&gt; 2</span></div><div class=line>vm.a = <span class=number>2</span></div><div class=line><span class=built_in>console</span>.log(vm.b) <span class=comment>// -&gt; 3</span></div></pre></td></tr></table></figure><p>你可以打开浏览器的控制台，修改例子的 vm。<code>vm.b</code> 的值始终取决于 <code>vm.a</code> 的值。</p> <p>你可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 <code>vm.b</code> 依赖于 <code>vm.a</code>，因此当 <code>vm.a</code> 发生改变时，依赖于 <code>vm.b</code> 的绑定也会更新。而且最妙的是我们是声明式地创建这种依赖关系：计算属性的 getter 是干净无副作用的，因此也是易于测试和理解的。</p> <h3 id=-vs-watch>计算属性 vs. $watch</h3> <p>Vue.js 提供了一个方法 <code>$watch</code>，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， <code>$watch</code> 很诱人 —— 特别是如果你来自 AngularJS。不过，通常更好的办法是使用计算属性而不是一个命令式的 <code>$watch</code> 回调。考虑下面例子：</p> <figure class=\"highlight html\"><table><tr><td class=code><pre><div class=line><span class=tag>&lt;<span class=name>div</span> <span class=attr>id</span>=<span class=string>\"demo\"</span>&gt;</span>{{fullName}}<span class=tag>&lt;/<span class=name>div</span>&gt;</span></div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=code><pre><div class=line><span class=keyword>var</span> vm = <span class=keyword>new</span> Vue({</div><div class=line>  data: {</div><div class=line>    firstName: <span class=string>'Foo'</span>,</div><div class=line>    lastName: <span class=string>'Bar'</span>,</div><div class=line>    fullName: <span class=string>'Foo Bar'</span></div><div class=line>  }</div><div class=line>})</div><div class=line></div><div class=line>vm.$watch(<span class=string>'firstName'</span>, <span class=function><span class=keyword>function</span> (<span class=params>val</span>) </span>{</div><div class=line>  <span class=keyword>this</span>.fullName = val + <span class=string>' '</span> + <span class=keyword>this</span>.lastName</div><div class=line>})</div><div class=line></div><div class=line>vm.$watch(<span class=string>'lastName'</span>, <span class=function><span class=keyword>function</span> (<span class=params>val</span>) </span>{</div><div class=line>  <span class=keyword>this</span>.fullName = <span class=keyword>this</span>.firstName + <span class=string>' '</span> + val</div><div class=line>})</div></pre></td></tr></table></figure><p>上面代码是命令式的重复的。跟计算属性对比：</p> <figure class=\"highlight js\"><table><tr><td class=code><pre><div class=line><span class=keyword>var</span> vm = <span class=keyword>new</span> Vue({</div><div class=line>  data: {</div><div class=line>    firstName: <span class=string>'Foo'</span>,</div><div class=line>    lastName: <span class=string>'Bar'</span></div><div class=line>  },</div><div class=line>  computed: {</div><div class=line>    fullName: <span class=function><span class=keyword>function</span> (<span class=params></span>) </span>{</div><div class=line>      <span class=keyword>return</span> <span class=keyword>this</span>.firstName + <span class=string>' '</span> + <span class=keyword>this</span>.lastName</div><div class=line>    }</div><div class=line>  }</div><div class=line>})</div></pre></td></tr></table></figure><p>更好，不是吗？</p> <h3 id=-setter>计算 setter</h3> <p>计算属性默认只是 getter，不过在需要时你也可以提供一个 setter：</p> <figure class=\"highlight js\"><table><tr><td class=code><pre><div class=line><span class=comment>// ...</span></div><div class=line>computed: {</div><div class=line>  fullName: {</div><div class=line>    <span class=comment>// getter</span></div><div class=line>    get: <span class=function><span class=keyword>function</span> (<span class=params></span>) </span>{</div><div class=line>      <span class=keyword>return</span> <span class=keyword>this</span>.firstName + <span class=string>' '</span> + <span class=keyword>this</span>.lastName</div><div class=line>    },</div><div class=line>    <span class=comment>// setter</span></div><div class=line>    set: <span class=function><span class=keyword>function</span> (<span class=params>newValue</span>) </span>{</div><div class=line>      <span class=keyword>var</span> names = newValue.split(<span class=string>' '</span>)</div><div class=line>      <span class=keyword>this</span>.firstName = names[<span class=number>0</span>]</div><div class=line>      <span class=keyword>this</span>.lastName = names[names.length - <span class=number>1</span>]</div><div class=line>    }</div><div class=line>  }</div><div class=line>}</div><div class=line><span class=comment>// ...</span></div></pre></td></tr></table></figure><p>现在在调用 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会有相应更新。</p> <p>关于计算属性背后的原理和技术细节详见响应系统介绍中的<a href=reactivity.html#计算属性的秘密>具体章节</a>。</p>"}});